{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"string-gen","text":"<p>Generate random strings from regular expression patterns.</p> <p>string-gen takes a regex pattern and produces random strings that match it. Common use cases include test data generation, fixtures, fuzzing, and mock data.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install string-gen\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from string_gen import StringGen\n\ngen = StringGen(r'(A|B)\\d{4}(\\.|-)\\d{1}')\nprint(gen.render())  # e.g. B9954.4\n\ngen = StringGen(r'[A-Z]{3}-\\d{3}')\nprint(gen.render_list(5))  # e.g. ['XKR-839', 'BNQ-271', 'JYL-054', 'WMT-692', 'AFZ-418']\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started \u2014 installation, basic usage, reproducible output</li> <li>Generation Methods \u2014 <code>render</code>, <code>render_list</code>, <code>render_set</code>, <code>stream</code>, <code>count</code>, <code>enumerate</code></li> <li>Configuration \u2014 <code>max_repeat</code>, custom alphabets, <code>configure()</code>, <code>reset()</code></li> <li>Regex Syntax \u2014 supported regex features and limitations</li> <li>API Reference \u2014 full API docs with signatures and parameters</li> <li>Built-in Patterns \u2014 UUID, IPv4, JWT, and more</li> <li>Alphabet Presets \u2014 Cyrillic, Greek, CJK, and 19 other scripts</li> <li>Cookbook \u2014 recipes for common scenarios</li> </ul>"},{"location":"examples/cookbook/","title":"Cookbook","text":"<p>Practical recipes for common string generation scenarios.</p>"},{"location":"examples/cookbook/#uuid","title":"UUID","text":"<pre><code>from string_gen import StringGen\nfrom string_gen.patterns import UUID4\n\ngen = StringGen(UUID4)\ngen.render()  # e.g. '52aabe4b-01fa-4b33-8976-b53b09f49e72'\n</code></pre>"},{"location":"examples/cookbook/#email-like-strings","title":"Email-like Strings","text":"<pre><code>gen = StringGen(r'[a-z]{5,10}@(gmail|yahoo|outlook)\\.com')\ngen.render()  # e.g. 'hqxvmr@gmail.com'\n</code></pre>"},{"location":"examples/cookbook/#api-testing","title":"API Testing","text":"<pre><code>from string_gen.patterns import API_KEY, JWT_LIKE\n\n# Stripe-like API key\ngen = StringGen(API_KEY)\ngen.render()  # e.g. 'sk_live_a3f2b1c45d6e4f7a8b9c'\n\n# JWT-like token\ngen = StringGen(JWT_LIKE)\ngen.render()  # e.g. 'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkw.SflKxwRJSMeKKF2QT4fwp'\n</code></pre>"},{"location":"examples/cookbook/#network-addresses","title":"Network Addresses","text":"<pre><code>from string_gen.patterns import IPV4, MAC_ADDRESS\n\ngen = StringGen(IPV4)\ngen.render()  # e.g. '192.168.1.42'\n\ngen = StringGen(MAC_ADDRESS)\ngen.render()  # e.g. 'a3:f2:b1:c4:5d:6e'\n</code></pre>"},{"location":"examples/cookbook/#i18n-testing","title":"i18n Testing","text":"<pre><code>from string_gen import StringGen\nfrom string_gen.alphabets import CYRILLIC, CJK, GREEK\n\n# Russian text\ngen = StringGen(r'\\w{10}', alphabet=CYRILLIC)\ngen.render()  # e.g. '\u0451\u0429\u043a\u0420\u0431\u043b\u043d\u042b\u0439\u041c'\n\n# Chinese characters\ngen = StringGen(r'\\w{5}', alphabet=CJK)\ngen.render()  # e.g. '\u6f22\u5b57\u751f\u6210\u5668'\n\n# Greek text\ngen = StringGen(r'\\w{8}', alphabet=GREEK)\ngen.render()  # e.g. '\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8'\n</code></pre>"},{"location":"examples/cookbook/#exhaustive-testing","title":"Exhaustive Testing","text":"<p>Generate all possible values for a finite pattern:</p> <pre><code>gen = StringGen(r'[ab]{2}')\n\n# Check total count\ngen.count()  # 4\n\n# Enumerate all combinations\nlist(gen.enumerate())  # ['aa', 'ab', 'ba', 'bb']\n</code></pre> <p>Use <code>enumerate</code> with <code>limit</code> for patterns that have unbounded quantifiers:</p> <pre><code>gen = StringGen(r'\\d+')\nlist(gen.enumerate(limit=1))  # ['0', '1', '2', ..., '9']\n</code></pre>"},{"location":"examples/cookbook/#reproducible-data","title":"Reproducible Data","text":"<p>Use <code>seed</code> for deterministic output across runs:</p> <pre><code>gen = StringGen(r'[A-Z]{3}-\\d{3}', seed=42)\ngen.render()  # always produces the same string\n\n# Re-seed to replay the sequence\ngen.seed(42)\ngen.render()  # same string again\n</code></pre>"},{"location":"examples/cookbook/#combining-patterns","title":"Combining Patterns","text":"<p>Use <code>|</code> to concatenate patterns:</p> <pre><code>prefix = StringGen(r'[A-Z]{3}')\nsuffix = StringGen(r'\\d{4}')\n\ncombined = prefix | suffix\ncombined.render()  # e.g. 'XKR8374'\n</code></pre> <p>Note</p> <p>The <code>|</code> operator strips trailing <code>$</code> from the left pattern and leading <code>^</code> from the right pattern before concatenation.</p>"},{"location":"examples/cookbook/#batch-generation","title":"Batch Generation","text":"<p>For large batches, <code>stream</code> is more memory-efficient than <code>render_list</code>:</p> <pre><code>gen = StringGen(r'\\d{10}')\n\n# Memory-efficient: yields one at a time\nfor value in gen.stream(100_000):\n    process(value)\n\n# Collects all into a list at once\nvalues = gen.render_list(100_000)\n</code></pre>"},{"location":"examples/cookbook/#unique-constraints","title":"Unique Constraints","text":"<p>Combine <code>render_set</code> with <code>count</code> to safely generate unique values:</p> <pre><code>gen = StringGen(r'[A-F]\\d')\n\n# Check if enough unique strings are possible\navailable = gen.count()  # 60\nassert available &gt;= 10\n\n# Generate 10 unique strings\nunique = gen.render_set(10)\nprint(unique)  # e.g. {'A3', 'B7', 'C1', 'D4', 'E9', 'F0', 'A8', 'B2', 'C5', 'D6'}\n</code></pre>"},{"location":"guide/configuration/","title":"Configuration","text":""},{"location":"guide/configuration/#max_repeat","title":"max_repeat","text":"<p>Unbounded quantifiers (<code>*</code>, <code>+</code>, <code>{n,}</code>) are capped at a maximum number of repetitions. The default is 100.</p> <p>You can set it per-instance:</p> <pre><code>from string_gen import StringGen\n\ngen = StringGen(r'\\w+', max_repeat=10)\ngen.render()  # 1-10 characters instead of 1-100\n</code></pre>"},{"location":"guide/configuration/#custom-alphabets","title":"Custom Alphabets","text":"<p>By default, character categories (<code>\\w</code>, <code>.</code>, <code>[^...]</code>) generate ASCII characters. Use the <code>alphabet</code> parameter to generate strings from other scripts:</p> <pre><code>from string_gen import StringGen\nfrom string_gen.alphabets import CYRILLIC, ASCII\n\n# Cyrillic word characters\ngen = StringGen(r'\\w{10}', alphabet=CYRILLIC)\ngen.render()  # e.g. '\u0451\u0429\u043a\u0420\u0431\u043b\u043d\u042b\u0439\u041c'\n\n# Mixed alphabets (combine with +)\ngen = StringGen(r'\\w{10}', alphabet=CYRILLIC + ASCII)\ngen.render()  # mix of Cyrillic and Latin letters\n\n# Custom alphabet \u2014 any string of letters\ngen = StringGen(r'\\w{5}', alphabet='\u03b1\u03b2\u03b3\u03b4\u03b5')\ngen.render()  # e.g. '\u03b3\u03b13\u03b4_'\n</code></pre> <p>See Alphabet Presets for all 22 available presets.</p>"},{"location":"guide/configuration/#configure","title":"configure()","text":"<p>Configure global defaults for all new <code>StringGen</code> instances. Per-instance values in the constructor take priority.</p> <pre><code>import string_gen\n\n# Set global max_repeat\nstring_gen.configure(max_repeat=20)\n\ngen = StringGen(r'\\w+')\ngen.render()  # 1-20 characters\n\n# Set global alphabet\nstring_gen.configure(alphabet=\"\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\")\n</code></pre> <p>Both parameters can be set at once:</p> <pre><code>string_gen.configure(max_repeat=20, alphabet=\"\u03b1\u03b2\u03b3\u03b4\u03b5\")\n</code></pre>"},{"location":"guide/configuration/#reset","title":"reset()","text":"<p>Reset all global settings (<code>max_repeat</code> and <code>alphabet</code>) to their defaults:</p> <pre><code>import string_gen\n\nstring_gen.configure(max_repeat=10, alphabet=\"\u03b1\u03b2\u03b3\u03b4\u03b5\")\nstring_gen.reset()  # back to max_repeat=100, alphabet=None (ASCII)\n</code></pre>"},{"location":"guide/configuration/#seed","title":"seed()","text":"<p>Re-seed the internal random number generator for reproducible output:</p> <pre><code>gen = StringGen(r'\\d{3}')\ngen.seed(42)\ngen.render()  # always the same result for the same seed\n</code></pre> <p>Seed can be set in the constructor too:</p> <pre><code>gen = StringGen(r'\\d{3}', seed=42)\n</code></pre> <p>Accepted seed types: <code>int</code>, <code>float</code>, <code>str</code>, <code>bytes</code>, <code>bytearray</code>, or <code>None</code>.</p>"},{"location":"guide/configuration/#priority","title":"Priority","text":"<p>Settings are resolved in this order (highest priority first):</p> <ol> <li>Constructor parameter \u2014 <code>StringGen(r'\\w+', max_repeat=5)</code></li> <li>Global configure() \u2014 <code>string_gen.configure(max_repeat=20)</code></li> <li>Default \u2014 <code>max_repeat=100</code>, <code>alphabet=None</code> (ASCII)</li> </ol> <pre><code>import string_gen\nfrom string_gen import StringGen\n\n# Default: max_repeat=100\ngen = StringGen(r'\\w+')\n\n# Global override: max_repeat=20\nstring_gen.configure(max_repeat=20)\ngen = StringGen(r'\\w+')  # uses 20\n\n# Constructor override: max_repeat=5\ngen = StringGen(r'\\w+', max_repeat=5)  # uses 5\n</code></pre>"},{"location":"guide/generation/","title":"Generation Methods","text":""},{"location":"guide/generation/#render","title":"render()","text":"<p>Produce a single random string matching the pattern.</p> <pre><code>from string_gen import StringGen\n\ngen = StringGen(r'[a-z]{5}')\ngen.render()  # e.g. 'qmxbr'\n</code></pre>"},{"location":"guide/generation/#render_list","title":"render_list()","text":"<p>Produce a list of <code>count</code> random strings. May contain duplicates.</p> <pre><code>gen = StringGen(r'\\d{3}')\ngen.render_list(3)  # e.g. ['847', '192', '503']\n</code></pre>"},{"location":"guide/generation/#render_set","title":"render_set()","text":"<p>Produce a set of <code>count</code> unique strings. Raises <code>StringGenMaxIterationsReachedError</code> if the iteration limit is reached before collecting enough unique values.</p> <pre><code>gen = StringGen(r'[01]')\ngen.render_set(2)  # {'0', '1'}\n</code></pre> <p>The optional <code>max_iteration</code> parameter controls the maximum number of generation attempts (default: 100,000):</p> <pre><code>gen = StringGen(r'\\d')\ngen.render_set(10, max_iteration=1_000)  # raises early if unlucky\n</code></pre> <p>If the pattern cannot produce enough unique strings, a <code>ValueError</code> is raised immediately:</p> <pre><code>gen = StringGen(r'[ab]')\ngen.render_set(5)  # ValueError: Cannot generate 5 unique strings: pattern can only produce 4\n</code></pre>"},{"location":"guide/generation/#iteration","title":"Iteration","text":"<p><code>StringGen</code> instances are iterable. Iterating yields an infinite stream of random matching strings:</p> <pre><code>gen = StringGen(r'\\d{4}')\n\nfor value in gen:\n    print(value)  # e.g. '8374'\n    break  # without break, iterates forever\n</code></pre> <p>Works with <code>itertools</code>:</p> <pre><code>from itertools import islice\n\ngen = StringGen(r'\\d{4}')\nvalues = list(islice(gen, 10))  # 10 random strings\n</code></pre>"},{"location":"guide/generation/#stream","title":"stream()","text":"<p>Return a lazy iterator that yields <code>count</code> random strings one at a time. Memory-efficient alternative to <code>render_list</code> for large batches:</p> <pre><code>gen = StringGen(r'\\d{4}')\nfor value in gen.stream(1000):\n    process(value)\n</code></pre>"},{"location":"guide/generation/#count","title":"count()","text":"<p>Return the number of unique strings the pattern can produce. Returns <code>math.inf</code> for patterns with unbounded quantifiers (<code>*</code>, <code>+</code>, <code>{n,}</code>). The result is cached after the first call.</p> <pre><code>gen = StringGen(r'[01]{3}')\ngen.count()  # 8\n\ngen = StringGen(r'\\d')\ngen.count()  # 10\n\ngen = StringGen(r'\\w+')\ngen.count()  # math.inf\n</code></pre>"},{"location":"guide/generation/#enumerate","title":"enumerate()","text":"<p>Yield all unique strings the pattern can produce. Useful for exhaustive testing over finite patterns.</p> <pre><code>gen = StringGen(r'[ab]{2}')\nlist(gen.enumerate())  # ['aa', 'ab', 'ba', 'bb']\n\ngen = StringGen(r'(yes|no)')\nlist(gen.enumerate())  # ['yes', 'no']\n</code></pre> <p>For patterns with unbounded quantifiers, <code>limit</code> caps the maximum repetition count. When <code>limit</code> is <code>None</code>, the parser's <code>max_repeat</code> value is used:</p> <pre><code>gen = StringGen(r'\\d+')\nlist(gen.enumerate(limit=1))  # ['0', '1', ..., '9']\n</code></pre>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#installation","title":"Installation","text":"pipuvpoetry <pre><code>pip install string-gen\n</code></pre> <pre><code>uv add string-gen\n</code></pre> <pre><code>poetry add string-gen\n</code></pre>"},{"location":"guide/getting-started/#basic-usage","title":"Basic Usage","text":"<p>Create a <code>StringGen</code> instance with a regex pattern, then call <code>render()</code> to produce a random matching string:</p> <pre><code>from string_gen import StringGen\n\ngen = StringGen(r'(A|B)\\d{4}(\\.|-)\\d{1}')\nprint(gen.render())  # e.g. B9954.4\nprint(gen.render())  # e.g. A5292-1\n</code></pre> <p>Each call to <code>render()</code> produces a new random string matching the pattern.</p>"},{"location":"guide/getting-started/#uuid-like-strings","title":"UUID-like Strings","text":"<p>Patterns can be as simple or complex as you need:</p> <pre><code>gen = StringGen(r'[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}')\nprint(gen.render())  # e.g. 52aabe4b-01fa-4b33-8976-b53b09f49e72\n</code></pre> <p>Or use the built-in <code>UUID4</code> pattern:</p> <pre><code>from string_gen.patterns import UUID4\n\ngen = StringGen(UUID4)\nprint(gen.render())  # e.g. 52aabe4b-01fa-4b33-8976-b53b09f49e72\n</code></pre>"},{"location":"guide/getting-started/#reproducible-output","title":"Reproducible Output","text":"<p>Pass a <code>seed</code> to get the same sequence every time:</p> <pre><code>gen = StringGen(r'\\d{4}', seed=42)\nprint(gen.render())  # always the same result for seed=42\n</code></pre>"},{"location":"guide/getting-started/#multiple-strings","title":"Multiple Strings","text":"<p>Generate a list or a set of strings:</p> <pre><code>gen = StringGen(r'[A-Z]{3}-\\d{3}')\n\n# List (may contain duplicates)\nprint(gen.render_list(5))  # e.g. ['XKR-839', 'BNQ-271', 'JYL-054', 'WMT-692', 'AFZ-418']\n\n# Set (all unique)\ngen = StringGen(r'\\d')\nprint(gen.render_set(10))  # {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}\n</code></pre>"},{"location":"guide/getting-started/#whats-next","title":"What's Next","text":"<ul> <li>Generation Methods \u2014 all methods for producing strings</li> <li>Configuration \u2014 control repeat limits, alphabets, and global settings</li> <li>Regex Syntax \u2014 supported regex features</li> </ul>"},{"location":"guide/patterns-syntax/","title":"Regex Syntax","text":""},{"location":"guide/patterns-syntax/#supported-features","title":"Supported Features","text":"Feature Syntax Example Literals <code>abc</code> <code>abc</code> Dot (any character) <code>.</code> <code>.{5}</code> Character classes <code>[abc]</code>, <code>[a-z]</code>, <code>[^0-9]</code> <code>[A-Za-z_]</code> Shorthand classes <code>\\d</code>, <code>\\D</code>, <code>\\w</code>, <code>\\W</code>, <code>\\s</code>, <code>\\S</code> <code>\\d{4}</code> Negated literal <code>[^x]</code> <code>[^a]</code> Quantifiers <code>{n}</code>, <code>{n,m}</code>, <code>*</code>, <code>+</code>, <code>?</code> <code>\\w{3,8}</code> Lazy quantifiers <code>{n,m}?</code>, <code>*?</code>, <code>+?</code>, <code>??</code> <code>\\d{1,5}?</code> Groups <code>(...)</code> <code>(abc)</code> Alternation <code>a\\|b</code> <code>(yes\\|no)</code> Backreferences <code>\\1</code>, <code>\\2</code> <code>(a)\\1</code> Anchors <code>^</code>, <code>$</code> <code>^\\d+$</code> Lookahead <code>(?=...)</code> <code>(?=prefix)</code> Negative lookahead <code>(?!...)</code> <code>(?!skip)</code>"},{"location":"guide/patterns-syntax/#limitations","title":"Limitations","text":"<ul> <li>Unbounded quantifiers capped \u2014 <code>*</code>, <code>+</code>, and <code>{n,}</code> default to 100 repetitions (configurable via <code>max_repeat</code> or <code>configure()</code>)</li> <li>No conditional backreferences \u2014 <code>(?(id)yes|no)</code> syntax is not supported</li> <li>Anchors are ignored \u2014 <code>^</code> and <code>$</code> do not constrain output; they are treated as empty strings</li> <li>Negative lookahead is ignored \u2014 <code>(?!...)</code> always produces an empty string</li> <li>Not a regex validator \u2014 the library generates strings matching the parsed AST, but does not guarantee coverage of all possible matches</li> </ul>"},{"location":"reference/alphabets/","title":"Alphabet Presets","text":"<p>The <code>string_gen.alphabets</code> module provides alphabet presets for non-ASCII string generation.</p>"},{"location":"reference/alphabets/#usage","title":"Usage","text":"<pre><code>from string_gen import StringGen\nfrom string_gen.alphabets import CYRILLIC, GREEK, ASCII\n\n# Cyrillic word characters\ngen = StringGen(r'\\w{10}', alphabet=CYRILLIC)\ngen.render()  # e.g. '\u0451\u0429\u043a\u0420\u0431\u043b\u043d\u042b\u0439\u041c'\n\n# Mixed alphabets (combine with +)\ngen = StringGen(r'\\w{10}', alphabet=CYRILLIC + ASCII)\ngen.render()  # mix of Cyrillic and Latin letters\n\n# Custom alphabet \u2014 any string of letters\ngen = StringGen(r'\\w{5}', alphabet='\u03b1\u03b2\u03b3\u03b4\u03b5')\ngen.render()  # e.g. '\u03b3\u03b13\u03b4_'\n</code></pre>"},{"location":"reference/alphabets/#available-presets","title":"Available Presets","text":"Preset Description <code>ASCII</code> <code>string.ascii_letters</code> (default) <code>CYRILLIC</code> Russian alphabet (\u0430-\u044f, \u0410-\u042f, \u0451, \u0401) <code>GREEK</code> Greek alphabet (\u03b1-\u03c9, \u0391-\u03a9) <code>LATIN_EXTENDED</code> ASCII + accented Latin characters <code>HIRAGANA</code> Japanese Hiragana <code>KATAKANA</code> Japanese Katakana <code>CJK</code> CJK Unified Ideographs <code>HANGUL</code> Korean Hangul syllables <code>ARABIC</code> Arabic script <code>DEVANAGARI</code> Devanagari script (Hindi, Marathi, Nepali) <code>THAI</code> Thai script <code>HEBREW</code> Hebrew script <code>BENGALI</code> Bengali/Bangla script <code>TAMIL</code> Tamil script <code>TELUGU</code> Telugu script <code>GEORGIAN</code> Georgian script <code>ARMENIAN</code> Armenian script <code>ETHIOPIC</code> Ethiopic/Ge'ez script (Amharic) <code>MYANMAR</code> Myanmar/Burmese script <code>SINHALA</code> Sinhala script <code>GUJARATI</code> Gujarati script <code>PUNJABI</code> Punjabi/Gurmukhi script"},{"location":"reference/alphabets/#how-alphabets-affect-categories","title":"How Alphabets Affect Categories","text":"<p>When <code>alphabet</code> is set, it replaces <code>string.ascii_letters</code> in character category resolution:</p> Category Behavior <code>\\w</code> <code>alphabet + digits + \"_\"</code> <code>\\W</code> everything in the printable set that is not in <code>\\w</code> <code>\\d</code> always <code>0-9</code> (unchanged) <code>\\D</code> everything in the printable set that is not <code>0-9</code> <code>\\s</code> always standard whitespace (unchanged) <code>\\S</code> everything in the printable set that is not whitespace <code>.</code> any character from the printable set except <code>\\n</code> <code>[^...]</code> negated class drawn from the printable set <p>The printable set is derived from the alphabet: <code>alphabet + digits + \"_\" + punctuation + whitespace</code>.</p>"},{"location":"reference/api/","title":"API Reference","text":""},{"location":"reference/api/#stringgen","title":"StringGen","text":""},{"location":"reference/api/#string_gen.StringGen","title":"string_gen.StringGen","text":"<pre><code>StringGen(\n    pattern: Union[Pattern, AnyStr],\n    seed: SeedType = None,\n    *,\n    max_repeat: Union[int, None] = None,\n    alphabet: Union[str, None] = None,\n)\n</code></pre> <p>Random string generator driven by a regular expression pattern.</p> <p>Compiles the given regex and produces random strings that match it. Supports literals, character classes, quantifiers, groups, alternation, anchors, lookahead assertions, and backreferences.</p> <p>The <code>max_repeat</code> parameter controls the upper bound for unbounded quantifiers (<code>*</code>, <code>+</code>, <code>{n,}</code>).  It can be set per-instance via the constructor or globally via :func:<code>configure</code>.</p> <p>Instances are iterable: iterating yields an infinite stream of random matching strings. Use :meth:<code>stream</code> for a bounded lazy generator.</p> <p>Instances can be combined with <code>|</code> to concatenate patterns, compared with <code>==</code> against other patterns, and tested for emptiness with <code>bool()</code>.</p>"},{"location":"reference/api/#string_gen.StringGen.pattern","title":"pattern  <code>property</code>","text":"<pre><code>pattern: Pattern\n</code></pre> <p>Compiled <code>re.Pattern</code> object used for generation.</p>"},{"location":"reference/api/#string_gen.StringGen.render","title":"render","text":"<pre><code>render() -&gt; str\n</code></pre> <p>Produce a single random string matching the pattern.</p>"},{"location":"reference/api/#string_gen.StringGen.render_list","title":"render_list","text":"<pre><code>render_list(count: int) -&gt; List[str]\n</code></pre> <p>Produce a list of random strings matching the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of strings to generate.</p> required"},{"location":"reference/api/#string_gen.StringGen.render_set","title":"render_set","text":"<pre><code>render_set(\n    count: int, *, max_iteration: int = 100000\n) -&gt; Set[str]\n</code></pre> <p>Produce a set of unique random strings matching the pattern.</p> <p>Keeps generating until count unique strings are collected or max_iteration attempts are exhausted.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Required number of unique strings.</p> required <code>max_iteration</code> <code>int</code> <p>Maximum generation attempts before giving up.</p> <code>100000</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If max_iteration is less than count.</p> <code>StringGenMaxIterationsReachedError</code> <p>If the iteration limit is reached before collecting enough unique strings.</p>"},{"location":"reference/api/#string_gen.StringGen.stream","title":"stream","text":"<pre><code>stream(count: int) -&gt; Iterator[str]\n</code></pre> <p>Return a lazy iterator that yields count random matching strings.</p> <p>Unlike :meth:<code>render_list</code>, strings are generated one at a time and never collected into a list, making <code>stream</code> memory-efficient for large batches.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of strings to yield.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If count is negative.</p> <p>.. code-block:: python</p> <pre><code>gen = StringGen(r\"\\d{4}\")\nfor value in gen.stream(1000):\n    process(value)\n</code></pre>"},{"location":"reference/api/#string_gen.StringGen.count","title":"count","text":"<pre><code>count() -&gt; Union[int, float]\n</code></pre> <p>Return the number of unique strings the pattern can produce.</p> <p>Returns <code>math.inf</code> for patterns with unbounded quantifiers (<code>*</code>, <code>+</code>, <code>{n,}</code>).  The result is cached after the first call.</p>"},{"location":"reference/api/#string_gen.StringGen.enumerate","title":"enumerate","text":"<pre><code>enumerate(\n    *, limit: Union[int, None] = None\n) -&gt; Iterator[str]\n</code></pre> <p>Yield all unique strings the pattern can produce.</p> <p>For patterns with unbounded quantifiers, limit caps the maximum repetition count.  When limit is <code>None</code> the parser's <code>max_repeat</code> value is used.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>Union[int, None]</code> <p>Maximum repetitions for unbounded quantifiers.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If limit is less than 1.</p>"},{"location":"reference/api/#string_gen.StringGen.seed","title":"seed","text":"<pre><code>seed(seed: SeedType = None) -&gt; None\n</code></pre> <p>Re-seed the internal random number generator.</p> <p>Calling with the same seed produces the same sequence of rendered strings.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>SeedType</code> <p>Seed value accepted by <code>random.Random.seed</code>.</p> <code>None</code>"},{"location":"reference/api/#configure","title":"configure","text":""},{"location":"reference/api/#string_gen.configure","title":"string_gen.configure","text":"<pre><code>configure(\n    *,\n    max_repeat: Union[int, None] = None,\n    alphabet: Union[str, None] = None,\n) -&gt; None\n</code></pre> <p>Configure global defaults for new <code>StringGen</code> instances.</p> <p>Settings apply to all subsequently created instances unless overridden in the constructor.  Omit a parameter to leave it unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>max_repeat</code> <code>Union[int, None]</code> <p>Maximum repetitions for unbounded quantifiers (<code>*</code>, <code>+</code>, <code>{n,}</code>).  Must be &gt;= 1.  Default is 100.</p> <code>None</code> <code>alphabet</code> <code>Union[str, None]</code> <p>Custom alphabet string replacing <code>string.ascii_letters</code> in all character categories.  Must be a non-empty string.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If max_repeat is less than 1.</p> <code>TypeError</code> <p>If alphabet is not a non-empty string.</p>"},{"location":"reference/api/#reset","title":"reset","text":""},{"location":"reference/api/#string_gen.reset","title":"string_gen.reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset all global settings to their defaults.</p>"},{"location":"reference/api/#exceptions","title":"Exceptions","text":""},{"location":"reference/api/#stringgenerror","title":"StringGenError","text":""},{"location":"reference/api/#string_gen.StringGenError","title":"string_gen.StringGenError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all string-gen errors.</p>"},{"location":"reference/api/#stringgenpatternerror","title":"StringGenPatternError","text":""},{"location":"reference/api/#string_gen.StringGenPatternError","title":"string_gen.StringGenPatternError","text":"<pre><code>StringGenPatternError(\n    pattern: Union[Pattern, AnyStr], *args\n)\n</code></pre> <p>               Bases: <code>StringGenError</code></p> <p>Exception raised when an invalid regex pattern is provided.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>Union[Pattern, AnyStr]</code> <p>The pattern that failed to compile.</p> required"},{"location":"reference/api/#stringgenmaxiterationsreachederror","title":"StringGenMaxIterationsReachedError","text":""},{"location":"reference/api/#string_gen.StringGenMaxIterationsReachedError","title":"string_gen.StringGenMaxIterationsReachedError","text":"<pre><code>StringGenMaxIterationsReachedError(\n    max_iterations: int, *args\n)\n</code></pre> <p>               Bases: <code>StringGenError</code></p> <p>Exception raised when <code>render_set</code> exhausts its iteration budget.</p> <p>Parameters:</p> Name Type Description Default <code>max_iterations</code> <code>int</code> <p>The iteration limit that was reached.</p> required"},{"location":"reference/patterns/","title":"Built-in Patterns","text":"<p>The <code>string_gen.patterns</code> module provides ready-to-use regex patterns for common data formats.</p>"},{"location":"reference/patterns/#usage","title":"Usage","text":"<pre><code>from string_gen import StringGen\nfrom string_gen.patterns import UUID4, IPV4, SEMVER\n\nStringGen(UUID4).render()   # e.g. '52aabe4b-01fa-4b33-8976-b53b09f49e72'\nStringGen(IPV4).render()    # e.g. '192.168.1.42'\nStringGen(SEMVER).render()  # e.g. '2.14.3'\n</code></pre>"},{"location":"reference/patterns/#available-patterns","title":"Available Patterns","text":""},{"location":"reference/patterns/#identifiers","title":"Identifiers","text":"Preset Example output Description <code>UUID4</code> <code>52aabe4b-01fa-4b33-8976-b53b09f49e72</code> UUID version 4 <code>OBJECT_ID</code> <code>507f1f77bcf86cd799439011</code> MongoDB ObjectId (24 hex chars)"},{"location":"reference/patterns/#network","title":"Network","text":"Preset Example output Description <code>IPV4</code> <code>192.168.1.42</code> IPv4 address (valid 0-255 octets) <code>IPV6_SHORT</code> <code>a3f2:b1c4:5d6e:4f7a:8b9c:0d1e:2f3a:4b5c</code> IPv6 address (simplified, no <code>::</code>) <code>MAC_ADDRESS</code> <code>a3:f2:b1:c4:5d:6e</code> MAC address"},{"location":"reference/patterns/#web","title":"Web","text":"Preset Example output Description <code>HEX_COLOR</code> <code>#a3f2b1</code> Hex color (6 digits) <code>HEX_COLOR_SHORT</code> <code>#a3f</code> Hex color (3 digits) <code>SLUG</code> <code>my-awesome-post</code> URL slug"},{"location":"reference/patterns/#data-formats","title":"Data Formats","text":"Preset Example output Description <code>SEMVER</code> <code>2.14.3</code> Semantic versioning <code>DATE_ISO</code> <code>2024-03-15</code> ISO 8601 date (2020-2039) <code>TIME_24H</code> <code>14:32:07</code> 24-hour time"},{"location":"reference/patterns/#security-auth","title":"Security / Auth","text":"Preset Example output Description <code>JWT_LIKE</code> <code>eyJhb...eyJzd...SflKx</code> JWT-like token structure <code>API_KEY</code> <code>sk_live_a3f2b1c45d6e4f7a8b9c</code> Stripe-like API key <p>Note</p> <p>All patterns avoid <code>\\w</code>, <code>\\d</code>, <code>\\s</code>, <code>.</code> shorthand classes, so they work correctly regardless of the <code>alphabet</code> setting.</p>"}]}